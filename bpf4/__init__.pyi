from typing import Iterator

from typing import Any, Callable, List, Optional, Tuple, Union

import numpy as np
from numpy.typing import NDArray


class BpfPointsError(ValueError): ...
class BpfInversionError(ValueError): ...


class BpfInterface:

    def _asbpf(self) -> 'BpfInterface': ...
    def _bounds_changed(self) -> None: ...
    def _set_bounds(self, x0: float, x1: float) -> None: ...
    def _set_bounds_like(self, a: 'BpfInterface') -> None: ...
    def ntodx(self, N: int) -> float: ...
    def dxton(self, dx: float) -> int: ...
    def bounds(self) -> Tuple[float, float]: ...

    @property
    def x0(self) -> float: ...

    @property
    def x1(self) -> float: ...

    def __add__(self, other: Union['BpfInterface', float]) -> 'BpfInterface': ...
    def __sub__(self, other: Union['BpfInterface', float]) -> 'BpfInterface': ...
    def __mul__(self, other: Union['BpfInterface', float]) -> 'BpfInterface': ...
    def __div__(self, other: Union['BpfInterface', float]) -> 'BpfInterface': ...
    def __truediv__(self, other: Union['BpfInterface', float]) -> 'BpfInterface': ...
    def __pow__(self, other: Union['BpfInterface', float, int], modulo: Optional[float] = None) -> 'BpfInterface': ...
    def __neg__(self) -> 'BpfInterface': ...
    def __mod__(self, other: Union['BpfInterface', float]) -> 'BpfInterface': ...
    def __abs__(self) -> 'BpfInterface': ...
    def __or__(self, other: Union['BpfInterface', Callable]) -> 'BpfInterface': ...
    def __rshift__(self, other: float) -> 'BpfInterface': ...
    def __lshift__(self, other: float) -> 'BpfInterface': ...
    def __xor__(self, other: float) -> 'BpfInterface': ...
    def __richcmp__(self, other: Any, op: int) -> 'BpfInterface': ...

    def _get_points_for_rendering(self, n: int = -1) -> Tuple[NDArray[np.float64], NDArray[np.float64]]: ...
    def render(self, xs: Union[int, List[float], NDArray[np.float64]], interpolation: str = 'linear') -> 'BpfInterface': ...
    def plot(self, kind: str = 'line', n: int = -1, show: bool = True, axes: Any = None, **keys: Any) -> Any: ...
    def sampled(self, dx: float, interpolation: str = 'linear') -> 'BpfInterface': ...
    def sample_between(self, x0: float, x1: float, dx: float, out: Optional[NDArray[np.float64]] = None) -> NDArray[np.float64]: ...
    def sampled_between(self, x0: float, x1: float, dx: float, interpolation: str = 'linear') -> 'BpfInterface': ...
    def mapn_between(self, n: int, x0: float, x1: float, out: Optional[NDArray[np.float64]] = None) -> NDArray[np.float64]: ...
    def map(self, xs: Union[int, NDArray[np.float64]], out: Optional[NDArray[np.float64]] = None) -> NDArray[np.float64]: ...
    def concat(self, other: 'BpfInterface') -> 'BpfInterface': ...
    def round(self) -> 'BpfInterface': ...
    def rand(self) -> 'BpfInterface': ...
    def cos(self) -> 'BpfInterface': ...
    def sin(self) -> 'BpfInterface': ...
    def ceil(self) -> 'BpfInterface': ...
    def expon(self) -> 'BpfInterface': ...
    def floor(self) -> 'BpfInterface': ...
    def tanh(self) -> 'BpfInterface': ...
    def abs(self) -> 'BpfInterface': ...
    def sqrt(self) -> 'BpfInterface': ...
    def acos(self) -> 'BpfInterface': ...
    def asin(self) -> 'BpfInterface': ...
    def tan(self) -> 'BpfInterface': ...
    def sinh(self) -> 'BpfInterface': ...
    def log10(self) -> 'BpfInterface': ...
    def log(self, base: float = 2.718281828459045) -> 'BpfInterface': ...
    def m2f(self, a4: float = 0.0) -> 'BpfInterface': ...
    def f2m(self, a4: float = 0.0) -> 'BpfInterface': ...
    def db2amp(self) -> 'BpfInterface': ...
    def amp2db(self) -> 'BpfInterface': ...
    def nanmask(self, masked: float = 0.0) -> 'BpfInterface': ...
    def linlin(self, u0: float, u1: float, v0: float, v1: float) -> 'BpfInterface': ...
    def clip(self, y0: float = float('-inf'), y1: float = float('inf')) -> 'BpfInterface': ...
    def derivative(self) -> 'BpfInterface': ...
    def integrated(self) -> 'BpfInterface': ...
    def integrate(self) -> float: ...
    def integrate_between(self, x0: float, x1: float, N: int = 0) -> float: ...
    def mean(self) -> float: ...
    def zeros(self, h: float = 0.01, N: int = 0, x0: float = float('nan'), x1: float = float('nan'), maxzeros: int = 0) -> List[float]: ...
    def max(self, b: Union[float, 'BpfInterface']) -> 'BpfInterface': ...
    def min(self, b: Union[float, 'BpfInterface']) -> 'BpfInterface': ...
    def __call__(self, x: float) -> float: ...
    def keep_slope(self, epsilon: float = 1e-10) -> 'BpfInterface': ...
    def outbound(self, y0: float, y1: Optional[float] = None) -> 'BpfInterface': ...
    def apply(self, func: Callable[[float], float]) -> 'BpfInterface': ...
    def preapply(self, func: Callable[[float], float]) -> 'BpfInterface': ...
    def periodic(self) -> 'BpfInterface': ...
    def stretched(self, rx: float, fixpoint: float = 0.0) -> 'BpfInterface': ...
    def fit_between(self, x0: float, x1: float) -> 'BpfInterface': ...
    def shifted(self, dx: float) -> 'BpfInterface': ...
    def inverted(self) -> Optional['BpfInterface']: ...
    def _slice(self, x0: float, x1: float) -> 'BpfInterface': ...
    def crop(self, x0: float, x1: float, y0: Optional[float] = None, y1: Optional[float] = None) -> 'BpfInterface': ...
    def copy(self) -> 'BpfInterface': ...

    @classmethod
    def fromseq(cls, *points: Union[Tuple[float, float], float], **kws: Any) -> 'BpfInterface': ...

class BpfBase(BpfInterface):

    def __init__(self, xs: Union[List[float], NDArray[np.float64]],
                 ys: Union[List[float], NDArray[np.float64]]) -> None: ...

    @property
    def descriptor(self) -> str: ...

    def outbound(self, y0: float, y1: Optional[float] = None) -> BpfInterface: ...

    def __getstate__(self) -> Tuple[NDArray[np.float64], NDArray[np.float64]]: ...

    def __setstate__(self, state: Tuple[NDArray[np.float64], NDArray[np.float64]]) -> None: ...

    def mapn_between(self, n: int, xstart: float, xend: float,
                    out: Optional[NDArray[np.float64]] = None) -> NDArray[np.float64]: ...

    def _mapn_between(self, n: int, xstart: float, xend: float,
                     out: Optional[NDArray[np.float64]] = None) -> NDArray[np.float64]: ...

    def stretch(self, rx: float) -> None: ...

    def shift(self, dx: float) -> None: ...

    def points(self) -> Tuple[NDArray[np.float64], NDArray[np.float64]]: ...

    def clone_with_new_data(self, xs: NDArray[np.float64],
                           ys: NDArray[np.float64]) -> BpfInterface: ...

    def insertpoint(self, x: float, y: float) -> BpfInterface: ...

    def removepoint(self, x: float) -> BpfInterface: ...

    def segments(self) -> Iterator[Tuple[float, float, str, float]]: ...

    def split(self, sep: float = float('nan')) -> List[BpfBase]: ...

    @property
    def exp(self) -> float: ...

    def _bounds_changed(self) -> None: ...

    def _invalidate_cache(self) -> None: ...

    def _recalculate_bounds(self) -> None: ...

    def __ccall__(self, x: float) -> float: ...


class Linear(BpfBase):

    def __init__(self,
                 xs: np.ndarray | list[float],
                 ys: np.ndarray | list[float]
                 ): ...


    def inverted(self) -> Linear: ...

    def flatpairs(self) -> np.ndarray: ...


class Smooth(BpfBase):
    def __init__(self,
                 xs: np.ndarray | list[float],
                 ys: np.ndarray | list[float]
                 ): ...


class Smoother(BpfBase):
    def __init__(self,
                 xs: np.ndarray | list[float],
                 ys: np.ndarray | list[float]
                 ): ...


class Halfcos(BpfBase):
    def __init__(self,
                 xs: np.ndarray | list[float],
                 ys: np.ndarray | list[float],
                 exp: float = 1.0, numiter: int =1): ...


class Halfcosm(Halfcos):
    def __init__(self,
                 xs: np.ndarray | list[float],
                 ys: np.ndarray | list[float],
                 exp: float = 1.0, numiter: int =1): ...


class Expon(BpfBase):
    def __init__(self,
                 xs: np.ndarray | list[float],
                 ys: np.ndarray | list[float],
                 exp: float = 1.0, numiter: int =1): ...


class Exponm(Expon):
    def __init__(self,
                 xs: np.ndarray | list[float],
                 ys: np.ndarray | list[float],
                 exp: float = 1.0, numiter: int =1): ...


class NoInterpol(BpfBase):
    def __init__(self,
                 xs: np.ndarray | list[float],
                 ys: np.ndarray | list[float]
                 ): ...


class Nearest(BpfBase):
    def __init__(self,
                 xs: np.ndarray | list[float],
                 ys: np.ndarray | list[float]
                 ): ...


class Sampled(BpfInterface):
    ys: NDArray[np.float64]

    def __init__(self, samples: Union[List[float], NDArray[np.float64]],
                 dx: float, x0: float = 0,
                 interpolation: str = 'linear') -> None: ...

    @property
    def samplerate(self) -> float: ...

    @property
    def xs(self) -> NDArray[np.float64]: ...

    def points(self) -> Tuple[NDArray[np.float64], NDArray[np.float64]]: ...

    @property
    def interpolation(self) -> str: ...
    @interpolation.setter
    def interpolation(self, value: str) -> None: ...

    @property
    def dx(self) -> float: ...

    def set_interpolation(self, interpolation: str) -> 'Sampled': ...

    def mapn_between(self, n: int, x0: float, x1: float,
                    out: Optional[NDArray[np.float64]] = None) -> NDArray[np.float64]: ...

    @classmethod
    def fromseq(cls, *args: Any, **kws: Any) -> None: ...

    def _get_points_for_rendering(self, n: int = -1) -> Tuple[NDArray[np.float64], NDArray[np.float64]]: ...

    def segments(self) -> Iterator[Tuple[float, float, str, float]]: ...

    def integrate(self) -> float: ...

    def integrate_between(self, x0: float, x1: float, N: int = 0) -> float: ...

    def derivative(self) -> BpfInterface: ...

    def inverted(self) -> Optional[BpfInterface]: ...

    def aslinear(self, simplify: float = 0.0) -> BpfInterface: ...

    def flatpairs(self) -> NDArray[np.float64]: ...

    def split(self, sep: float = float('nan')) -> List['Sampled']: ...


class Spline(BpfInterface):
    def __init__(self,
                 xs: np.ndarray | list[float],
                 ys: np.ndarray | list[float]
                 ): ...


class USpline(BpfInterface):
    def __init__(self,
                 xs: np.ndarray | list[float],
                 ys: np.ndarray | list[float]
                 ): ...


class Slope(BpfInterface):

    @property
    def slope(self) -> float: ...

    @slope.setter
    def slope(self, value: float) -> None: ...

    @property
    def offset(self) -> float: ...

    @offset.setter
    def offset(self, value: float) -> None: ...


class _BpfCompose(BpfInterface): ...


class _BpfConcat(BpfInterface): ...


class _BpfBlend(BpfInterface): ...


class Multi(BpfInterface):

    def __init__(self,
                 xs: Union[List[float], NDArray[np.float64]],
                 ys: Union[List[float], NDArray[np.float64]],
                 interpolations: List[str]) -> None: ...

    def __getstate__(self) -> Tuple[List[float], List[float], List[str]]: ...

    def segments(self) -> Iterator[Tuple[float, float, str, float]]: ...



class Const(BpfInterface): ...


class _MultipleBpfs(BpfInterface):

    def __init__(self, bpfs: list[BpfInterface]): ...


class Max(_MultipleBpfs): ...

class Min(_MultipleBpfs): ...

class Stack(_MultipleBpfs): ...

class Pchip(BpfInterface): ...



def brentq(bpf: BpfInterface, x0: float, xa: float, xb: float, xtol=9.9999999999999998e-13,
           rtol=4.4408920985006262e-16, max_iter=100) -> tuple[float,int]: ...


def blend(a: BpfInterface, b: BpfInterface, mix=0.5) -> BpfInterface: ...



def bpf_zero_crossings(b: BpfInterface,
                       h: float = 0.01, N: int = 0,
                       x0: float = float('nan'),
                       x1: float = float('nan'),
                       maxzeros: int = 0
                       ) -> list[float]: ...


def linear(*args) -> Linear: ...

def expon(*args, **kws) -> Expon: ...

def halfcos(*args, exp=1, numiter=1, **kws) -> Halfcos: ...

def halfcosm(*args, **kws) -> Halfcosm: ...

def spline(*args) -> Spline: ...

def uspline(*args) -> USpline: ...

def multi(*args) -> Multi: ...

def pchip(*args) -> Pchip: ...
